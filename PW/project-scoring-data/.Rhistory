<<<<<<< HEAD
# 5              SAVINGS_ACCT      0.196009557    5        0     Average
# 6                   PURPOSE      0.169155274    9        0     Average
# 7        AMOUNT_TO_DURATION      0.114469395    6        0     Average
# 8                  PROPERTY      0.112638262    4        0     Average
# 9                 EMLOYMENT      0.086433631    5        0        Weak
# 10                  HOUSING      0.082950783    2        0        Weak
# 11                      AGE      0.073166424    2        0        Weak
# 12  OTHER_INSTALLMENT_PLANS      0.057614542    3        0        Weak
# 13           STATUS_AND_SEX      0.044670678    4        0        Weak
# 14        IS_FOREIGN_WORKER      0.043877412    2        0        Weak
# 15            OTHER_DEBTORS      0.032019322    3        0        Weak
# 16      RATE_TO_DISP_INCOME      0.023858552    2        0        Weak
# 17 NUM_OF_THIS_BANK_CREDITS      0.010083557    2        0   Wery weak
# 18                      JOB      0.008095050    3        0   Wery weak
# 19                TELEPHONE      0.006377605    2        0   Wery weak
# 20 NUM_OF_MAINTAINED_PEOPLE      0.000000000    1        0   Wery weak
# 21                RESIDENCE      0.000000000    1        0   Wery weak
#' At this point we REMOVE:
#' - NUM_OF_MAINTAINED_PEOPLE
#' - RESIDENCE
#' variables
col.to.remove.idx <- which(names(gcredit.cat) %in% c("NUM_OF_MAINTAINED_PEOPLE", "RESIDENCE"))
gcredit.cat <- gcredit.cat[, -col.to.remove.idx]
(iv.mult.res <- iv.mult(gcredit.cat,"RES", TRUE))
# ------------------------------------------------------------------------------
# Save categorized data to a file
# Reorder columns in data frame to have firsty numeric, then factor variables
num.cols <- which(sapply(gcredit.cat, class) == "numeric")
gcredit.cat <- gcredit.cat[c(num.cols, setdiff(1:ncol(gcredit.cat), num.cols))]
# Save tmp version of the data
write.table(x = gcredit.cat, file = "./data/german_data_cat.txt",
sep=",",  col.names=TRUE, row.names = FALSE)
# # Read data
# gcredit.cat <-
#   read.table("./data/german_data_cat.txt", sep=",", header =TRUE,
#              colClasses=c(rep("numeric", 3), rep("character", 17)))
iv.plot.summary(iv.mult.res) # very nice plot! :)
# WoE patterns for "Very strong" / "Strong" variables
iv.plot.woe(iv.mult(gcredit.cat,"RES",vars=c("CHK_ACCT"),summary=FALSE))
iv.plot.woe(iv.mult(gcredit.cat,"RES",vars=c("HISTORY"),summary=FALSE))
iv.plot.woe(iv.mult(gcredit.cat,"RES",vars=c("DURATION"),summary=FALSE))
iv.plot.woe(iv.mult(gcredit.cat,"RES",vars=c("AMOUNT"),summary=FALSE))
iv.plot.woe(iv.mult(gcredit.cat,"RES",vars=c("AMOUNT"),summary=FALSE))
# Replace WoE for all variables
gcredit.woe <- iv.replace.woe(gcredit.cat, iv.mult(gcredit.cat,"RES"))
gcredit.woe <- gcredit.woe[, c(which(names(gcredit.woe) == "RES"),
grep("woe", names(gcredit.woe)))]
# ------------------------------------------------------------------------------
# Save recoded to WoE data to a file
write.table(x = gcredit.woe, file = "./data/german_data_woe.txt",
sep=",",  col.names=TRUE, row.names = FALSE)
str(gcredit.cat)
str(gcredit.woe)
=======
library(reshape)
library(dplyr)
library(MASS)
library(pander)
library(stringr)
library(rpart)
# to install under Ubuntu, follow: http://stackoverflow.com/questions/13403268/error-while-loading-rjava
library(rJava)
library(RWekajars)
library(RWeka)
library(FSelector)
#' After modeling part it is impoortant to show some of the diagnostics for the
#' model
#' We predict probabilities for the classes and then we can compare them using
#' distribution,
#'  histogram and ROC curve
#' In order to perform analysis form of the scores should be as follows
#' It suppose to be data frame with two columns - scores with values of
#' probability and flag (GOOD/BAD) for each case
#' Function to plot a histogram for the data
#' @param probablities - data frame with scores and flag GOOD/BAD for
#' observations
#' @param bins - number of bins for the histogram
#' @return p - histogram
plot_hist <- function(probabilities, bins = 30){
binwidth <- (max(probabilities$score)-min(probabilities$score))/bins
p <- ggplot(probabilities, aes(score, fill = flag))
p <- p + geom_histogram(alpha = 0.7
, aes(y = ..density..)
, position = 'identity'
, binwidth = binwidth)
return(p)
}
#' Function to calculate GINI and AUROC indexes
#' @param fraction.GOOD fraction of observations with GOOD flag for
#' certain interval
#' @param fraction.BAD fraction of observations with BAD flag for
#' certain interval
#' @return list of calculated coefficients: GINI, AUROC
calculate_ROC_GINI <- function(fraction.GOOD, fraction.BAD){
k <- length(fraction.GOOD)
df <- data.frame(LOWER_T_NUM = fraction.GOOD[1:(k-1)]
, UPPER_F_NUM = fraction.BAD[2:k]
, UPPER_T_NUM = fraction.GOOD[2:k]
, LOWER_F_NUM = fraction.BAD[1:(k-1)])
# Area under ROC curve and GINI coefficient
T_DIFFERENCE <- df$UPPER_T_NUM - df$LOWER_T_NUM
F_DIFFERENCE <- df$UPPER_F_NUM - df$LOWER_F_NUM
Area <- (T_DIFFERENCE * F_DIFFERENCE)/2 + df$UPPER_F_NUM * T_DIFFERENCE
AUROC <- sum(Area)
GINI <- 2 * AUROC - 1
return(list(GINI = GINI, AUROC = AUROC))
}
#' Funtion to calculate GINI and AUROC index
#' @param probablities - data frame with scores and flag GOOD/BAD for observations
#' @param thershold - value of length of the interval
#' @return list of fractions of GOOD and BAD observations calculated within intervals
calculate_fractions <- function(probabilities, threshold){
# Calculation number of observations for flags
n <- sum(probabilities$flag == "GOOD")
m <- sum(probabilities$flag == "BAD")
# Construction of intervals
division <- seq(min(probabilities$score), max(probabilities$score), by = threshold)
k <- length(division)
fraction.GOOD <- fraction.BAD <- rep(0, k)
# Calculation of appropriate values
fraction.GOOD <- sapply(division
, function(x) sum(ifelse(probabilities$score <= x & probabilities$flag=="GOOD", 1, 0)))/n
fraction.BAD <- sapply(division
, function(x) sum(ifelse(probabilities$score <= x & probabilities$flag=="BAD", 1, 0)))/m
return(list(fraction.GOOD = c(0, fraction.GOOD),fraction.BAD = c(0, fraction.BAD), division = c(0, division)))
}
#' Funtion to plot ROC curve with the GINI and AUROC index
#' @param fraction.GOOD - vector of cumulative fraction of good observations for intervals
#' @param fraction.BAD - vector of cumulative fraction of bad observations for intervals
#' @param index - calculated values of GINI and AUROC indexes
#' @return p - plot of ROC curve
plot_ROC <- function(fraction.GOOD, fraction.BAD, index){
df <- data.frame(fraction.GOOD, fraction.BAD)
p <- ggplot(data = df, aes(x = fraction.GOOD, y = fraction.BAD, color = "Red")) +
geom_line(alpha = 1, size = 1.2) +
labs(title = "ROC curve") +
ylab("True Positive Rate (Sensitivity)") +
xlab("False Positive Rate (1-Specificity)") +
theme(plot.title = element_text(lineheight =.8, face ="bold")) +
geom_text(data = NULL, x = 0.75, y = 0.05, label = paste("AUROC =",round(index$AUROC,4)), color = "Black") +
geom_text(data = NULL, x = 0.75, y = 0.15, label = paste("GINI =",round(index$GINI,4)), color = "Black") + ylim(0,1) + xlim(0,1)
return(p)
}
#' Funtion to plot ROC curve with the GINI and AUROC index
#' @param fraction.GOOD - vector of cumulative fraction of good observations for intervals
#' @param fraction.BAD - vector of cumulative fraction of bad observations for intervals
#' @param division - values for interval bands
#' @return p - plot of ROC curve
plot_distribution <- function(fraction.GOOD, fraction.BAD, division){
df <- data.frame(scores = c(fraction.GOOD, fraction.BAD)
, division = c(division, division)
, etykieta = as.factor(c(rep("F(s|GOOD)", length(division)), rep("F(s|BAD)", length(division)))))
KS <- max(abs(fraction.GOOD - fraction.BAD))
p <- ggplot(data = df, aes(x = division, y = scores, color = etykieta)) +
geom_line(alpha = 1,size = 1.2) +
labs(title = "Wykres dystrybuant") +
ylab("Prawdopodobienstwo") +
xlab("x") +
theme(plot.title = element_text(lineheight = .8, face = "bold")) +
geom_text(data = NULL, x = 0.4, y = 0.05, label = paste("KS =", round(KS,4)), color = "Black")
return(p)
}
#' Tests for appropriate pr value
#' frac <- calculate_fractions(probabilities = pr, threshold = 0.01)
#' ind <- calculate_ROC_GINI(fraction.GOOD = frac$fraction.GOOD, fraction.BAD = frac$fraction.BAD)
#' plot_hist(pr,20)
#' plot_ROC(fraction.GOOD = frac$fraction.GOOD, fraction.BAD = frac$fraction.BAD, index = ind)
#' plot_distribution(fraction.GOOD = frac$fraction.GOOD, fraction.BAD = frac$fraction.BAD, division = frac$division)
pr_rf <- predict(rfFit, newdata = testing, type = "prob")
pr_rf<-data.frame(score=pr_rf$GOOD
,flag=ifelse(testing$RES == "GOOD","GOOD","BAD"))
frac <- calculate_fractions(probabilities = pr_rf, threshold = 0.01)
ind <- calculate_ROC_GINI(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD)
plot_hist(pr_rf,20)
plot_ROC(fraction.GOOD = frac$fraction.GOOD
,fraction.BAD = frac$fraction.BAD, index = ind)
plot_distribution(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD, division = frac$division)
pr_gbm <- predict(gbmFit3, newdata = testing, type = "prob")
pr_gbm<-data.frame(score=pr_gbm$GOOD
,flag=ifelse(testing$RES == "GOOD","GOOD","BAD"))
frac <- calculate_fractions(probabilities = pr_gbm, threshold = 0.01)
ind <- calculate_ROC_GINI(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD)
plot_hist(pr_gbm,20)
plot_ROC(fraction.GOOD = frac$fraction.GOOD
,fraction.BAD = frac$fraction.BAD, index = ind)
plot_distribution(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD, division = frac$division)
pr_glmAIC_ <- predict(glmFit_best, newdata = testing, type = "prob")
pr_glmAIC_<-data.frame(score=pr_glmAIC_$GOOD
,flag=ifelse(testing$RES == "GOOD","GOOD","BAD"))
frac <- calculate_fractions(probabilities = pr_glmAIC_, threshold = 0.01)
ind <- calculate_ROC_GINI(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD)
plot_hist(pr_glmAIC_,20)
plot_ROC(fraction.GOOD = frac$fraction.GOOD
,fraction.BAD = frac$fraction.BAD, index = ind)
plot_distribution(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD, division = frac$division)
pr_lda <- predict(ldaFit_best, newdata = testing_woe, type = "prob")
pr_lda<-data.frame(score=pr_lda$GOOD
,flag=ifelse(testing_woe$RES == "GOOD","GOOD","BAD"))
frac <- calculate_fractions(probabilities = pr_lda, threshold = 0.01)
ind <- calculate_ROC_GINI(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD)
plot_hist(pr_lda,20)
plot_ROC(fraction.GOOD = frac$fraction.GOOD
,fraction.BAD = frac$fraction.BAD, index = ind)
plot_distribution(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD, division = frac$division)
pr_knn <- predict(knnFit, newdata = testing_woe, type = "prob")
pr_knn<-data.frame(score=pr_knn$GOOD
,flag=ifelse(testing_woe$RES == "GOOD","GOOD","BAD"))
frac <- calculate_fractions(probabilities = pr_knn, threshold = 0.01)
ind <- calculate_ROC_GINI(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD)
plot_hist(pr_knn,20)
plot_ROC(fraction.GOOD = frac$fraction.GOOD
,fraction.BAD = frac$fraction.BAD, index = ind)
plot_distribution(fraction.GOOD = frac$fraction.GOOD
, fraction.BAD = frac$fraction.BAD, division = frac$division)
library (ROCR)
ggplot(gbmFit3)
ggplot(rfFit)
ggplot(knnFit_best)
trellis.par.set(caretTheme())
plot(gbmFit3, plotType = "level",
scales = list(x = list(rot = 90)))
resamps <- resamples(list(GBM = gbmFit3,
RF = rfFit,
KNN = knnFit,
GLM = glmFit_best))
theme1 <- trellis.par.get()
summary(resamps)
trellis.par.set(theme1)
bwplot(resamps, layout = c(3, 1))
splom(resamps)
difValues <- diff(resamps)
difValues
trellis.par.set(theme1)
bwplot(difValues, layout = c(3, 1))
>>>>>>> 1b9fd1c652051485f7c6d8d386cd40424d20c20d
#' @description
#' Project configuration file.
#'
#' Contains:
#'  - setting of working directory (depenfing on user's comupter name)
#'  - loading all libraries used in the project
#'  - sourcing of all util scipts used in project
# ------------------------------------------------------------------------------
# Set working directory
computer.name <- Sys.info()["nodename"]
if (computer.name == "marta-komputer")
wd.tmp <- "/home/martakarass/my-store/studies/PW/project-scoring-data"
if (computer.name == "MATHPASSION")
wd.tmp <- "C:/Users/Math/studia/studies/PW/project-scoring-data"
if (computer.name == "JIDZIAK-L")
wd.tmp <- "C:/Users/jidziak/Desktop/Projekt worzenie modelu"
setwd(wd.tmp)
# ------------------------------------------------------------------------------
# Load libraries
library(corrgram)
library(ggplot2)
require(stringr)
setInternet2(TRUE)
setInternet2(FALSE)
#' To load `woe` package:
#' 1. download woe-master.zip from https://github.com/tomasgreif/woe
#' 2. unzip it
#' 3. install from source:
#' install.packages("./woe-master", repos = NULL, type="source")
library(woe)
library(caret)
library(pROC)
library(smbinning)
library(reshape)
library(dplyr)
library(MASS)
library(pander)
library(stringr)
library(rpart)
# to install under Ubuntu, follow: http://stackoverflow.com/questions/13403268/error-while-loading-rjava
library(rJava)
library(RWekajars)
library(RWeka)
library(FSelector)
<<<<<<< HEAD
library(fpc)
# ------------------------------------------------------------------------------
# Source project util scripts
source("./R/UTILS_data_preprocessing.R")
#' @author
#' Marta Karaś, Jan Idziak
#'
#' @description
#' The script performs preprocessing STEP 2. of German Credit dataset.
#'
#'
#' Includes:
#'  - data formattng
#'  - searching for and dealing with missing, corrupt and invalid data
#'  - creating derived variables
#'  - binning countinuous variables
#'  - correcting bins (levels) of categorical variables
#'    (combining levels if needed)
#'  - recoding data to WoE
#'
#'
#'  Results in:
#'  - "./data/german_data_cat.txt" - categorized (binned) data set
#'  - "./data/german_data_woe.txt" - recoded to WoE data set
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------
# READ DATA
# Read data (numbers - except from response variable - are read as numeric)
gcredit <-
read.table("./data/german_data_processed1.txt", sep=",", header =TRUE,
colClasses=c(rep("numeric", 8), rep("character", 13)))
# Relevel factors to keep original "order"
for(col.name in names(gcredit))
gcredit[, col.name] <- gcredit.convert.to.factor(col.name, gcredit[, col.name])
# ------------------------------------------------------------------------------
# CELANING DATA
#-----------------------------------------------
# Dealing with missing, corrupt and invalid data
names(gcredit)
# [1] "CHK_ACCT"                 "DURATION"
# [3] "HISTORY"                  "PURPOSE"
# [5] "AMOUNT"                   "SAVINGS_ACCT"
# [7] "EMLOYMENT"                "RATE_TO_DISP_INCOME"
# [9] "STATUS_AND_SEX"           "OTHER_DEBTORS"
# [11] "RESIDENCE"                "PROPERTY"
# [13] "AGE"                      "OTHER_INSTALLMENT_PLANS"
# [15] "HOUSING"                  "NUM_OF_THIS_BANK_CREDITS"
# [17] "JOB"                      "NUM_OF_MAINTAINED_PEOPLE"
# [19] "TELEPHONE"                "IS_FOREIGN_WORKER"
# [21] "RES"
# We look for any outliers, invalid data etc. among numeric variables
# DURATION
=======
library (ROCR)
splom(resamps)
theme1 <- trellis.par.get()
trellis.par.set(theme1)
bwplot(difValues, layout = c(3, 1))
splom(resamps)
install.packages("ROCR")
install.packages("fpc")
e
x.vec <- gcredit$AGE
gcredit <-
read.table(paste0(wd, "/data/german_data_processed1.txt"), sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
# Relevel factors to keep original "order"
for(col.name in names(gcredit))
gcredit[, col.name] <- gcredit.convert.to.factor(col.name, gcredit[, col.name])
gcredit <-
read.table(paste0(wd, "/data/german_data_processed1.txt"), sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
read.table( "/data/german_data_processed1.txt"), sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
read.table( "/data/german_data_processed1.txt"), sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
# Relevel factors to keep original "order"
for(col.name in names(gcredit))
read.table("/data/german_data_processed1.txt", sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
# Relevel factors to keep original "order"
read.table("/data/german_data_processed1.txt", sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
read.table("./data/german_data_processed1.txt", sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
read.table("./data/german_data_processed1.txt", sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
# Relevel factors to keep original "order"
gcredit <-
read.table("./data/german_data_processed1.txt", sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
# Relevel factors to keep original "order"
for(col.name in names(gcredit))
gcredit[, col.name] <- gcredit.convert.to.factor(col.name, gcredit[, col.name])
@
>>>>>>> 1b9fd1c652051485f7c6d8d386cd40424d20c20d
x.vec <- gcredit$DURATION
x <- seq(min(x.vec)-1, max(x.vec)+1, length.out = 1000)
par(mfrow=c(1,3))
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "Gamma") ## fitting gamma pdf parameters
lines(x, dgamma(x, rate=fit$estimate["rate"], shape=fit$estimate["shape"]), col = 2, lwd = 2)
legend("topright", legend = c("estimator", "Gamma"), col = c(1,2), cex = 1, lwd = 3)
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "weibull") ## fitting gamma pdf parameters
lines(x, dweibull(x, shape =fit$estimate["shape"], scale = fit$estimate["scale"]), col = 4, lwd = 2)
legend("topright", legend = c("estimator", "Weibull"), col = c(1,4), cex = 1, lwd = 3)
<<<<<<< HEAD
# Print best results
fitdistr(x.vec, "log-normal")
# AMOUNT
=======
@
\caption{Kernel density estimate of $DURATION$ variable density (black line) and curves representing density of the distribution fitted.}
>>>>>>> 1b9fd1c652051485f7c6d8d386cd40424d20c20d
x.vec <- gcredit$AMOUNT
x <- seq(min(x.vec)-1, max(x.vec)+1, length.out = 1000)
par(mfrow=c(1,3))
plot(density(x.vec), main = "AMOUNT", lwd=2)
<<<<<<< HEAD
fit <- fitdistr(x.vec, "Gamma") ## fitting gamma pdf parameters
lines(x, dgamma(x, rate=fit$estimate["rate"], shape=fit$estimate["shape"]), col = 2, lwd = 2)
=======
# fit <- fitdistr(x.vec, "Gamma") ## fitting gamma pdf parameters
# lines(x, dgamma(x, rate=fit$estimate["rate"], shape=fit$estimate["shape"]), col = 2, lwd = 2)
>>>>>>> 1b9fd1c652051485f7c6d8d386cd40424d20c20d
legend("topright", legend = c("estimator", "Gamma"), col = c(1,2), cex = 1, lwd = 3)
#par(mfrow=c(1,2))
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "weibull") ## fitting gamma pdf parameters
lines(x, dweibull(x, shape =fit$estimate["shape"], scale = fit$estimate["scale"]), col = 4, lwd = 2)
<<<<<<< HEAD
legend("topright", legend = c("estimator", "Weibull"), col = c(1,4), cex = 1, lwd = 3)
# Print best results
fitdistr(x.vec, "log-normal")
=======
par(mfrow=c(1,3))
plot(density(x.vec), main = "AMOUNT", lwd=2)
# fit <- fitdistr(x.vec, "Gamma") ## fitting gamma pdf parameters
# lines(x, dgamma(x, rate=fit$estimate["rate"], shape=fit$estimate["shape"]), col = 2, lwd = 2)
legend("topright", legend = c("estimator", "Gamma"), col = c(1,2), cex = 1, lwd = 3)
#par(mfrow=c(1,2))
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
#par(mfrow=c(1,2))
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "weibull") ## fitting gamma pdf parameters
lines(x, dweibull(x, shape =fit$estimate["shape"], scale = fit$estimate["scale"]), col = 4, lwd = 2)
legend("topright", legend = c("estimator", "Weibull"), col = c(1,4), cex = 1, lwd = 3)
#par(mfrow=c(1,2))
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
#par(mfrow=c(1,2))
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "weibull") ## fitting gamma pdf parameters
lines(x, dweibull(x, shape =fit$estimate["shape"], scale = fit$estimate["scale"]), col = 4, lwd = 2)
legend("topright", legend = c("estimator", "Weibull"), col = c(1,4), cex = 1, lwd = 3)
#par(mfrow=c(1,2))
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
#par(mfrow=c(1,2))
plot(density(x.vec), main = "AMOUNT", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
x.vec <- gcredit$DURATION
x <- seq(min(x.vec)-1, max(x.vec)+1, length.out = 1000)
par(mfrow=c(1,3))
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "Gamma") ## fitting gamma pdf parameters
lines(x, dgamma(x, rate=fit$estimate["rate"], shape=fit$estimate["shape"]), col = 2, lwd = 2)
legend("topright", legend = c("estimator", "Gamma"), col = c(1,2), cex = 1, lwd = 3)
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "weibull") ## fitting gamma pdf parameters
lines(x, dweibull(x, shape =fit$estimate["shape"], scale = fit$estimate["scale"]), col = 4, lwd = 2)
legend("topright", legend = c("estimator", "Weibull"), col = c(1,4), cex = 1, lwd = 3)
par(mfrow=c(1,3))
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "Gamma") ## fitting gamma pdf parameters
lines(x, dgamma(x, rate=fit$estimate["rate"], shape=fit$estimate["shape"]), col = 2, lwd = 2)
legend("topright", legend = c("estimator", "Gamma"), col = c(1,2), cex = 1, lwd = 3)
plot(density(x.vec), main = "DURATION", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
>>>>>>> 1b9fd1c652051485f7c6d8d386cd40424d20c20d
# AGE
x.vec <- gcredit$AGE
x <- seq(min(x.vec)-1, max(x.vec)+1, length.out = 1000)
par(mfrow=c(1,3))
plot(density(x.vec), main = "AGE", lwd=2)
fit <- fitdistr(x.vec, "Gamma") ## fitting gamma pdf parameters
lines(x, dgamma(x, rate=fit$estimate["rate"], shape=fit$estimate["shape"]), col = 2, lwd = 2)
legend("topright", legend = c("estimator", "Gamma"), col = c(1,2), cex = 1, lwd = 3)
plot(density(x.vec), main = "AGE", lwd=2)
fit <- fitdistr(x.vec, "log-normal") ## fitting gamma pdf parameters
lines(x, dlnorm(x, meanlog = fit$estimate["meanlog"], sdlog = fit$estimate["sdlog"]), col = 3, lwd = 2)
legend("topright", legend = c("estimator", "log normal"), col = c(1,3), cex = 1, lwd = 3)
plot(density(x.vec), main = "AGE", lwd=2)
fit <- fitdistr(x.vec, "weibull") ## fitting gamma pdf parameters
lines(x, dweibull(x, shape =fit$estimate["shape"], scale = fit$estimate["scale"]), col = 4, lwd = 2)
legend("topright", legend = c("estimator", "Weibull"), col = c(1,4), cex = 1, lwd = 3)
<<<<<<< HEAD
# Print best results
fitdistr(x.vec, "log-normal")
summary(gcredit)
summary(gcredit$RATE_TO_DISP_INCOME)
plot(density(gcredit$RATE_TO_DISP_INCOME))
summary(gcredit$RESIDENCE)
plot(density(gcredit$RESIDENCE))
summary(gcredit$AGE)
plot(density(gcredit$AGE)) # Interesting
summary(gcredit$NUM_OF_MAINTAINED_PEOPLE)
plot(density(gcredit$NUM_OF_MAINTAINED_PEOPLE))
#' Observation:
#' there is no obviously "bad" observations or strange distributions
#' --------------------------
#' Creating derived variables
# Check the correlations
corrgram(gcredit[1:7], order=TRUE, lower.panel=panel.pie,
upper.panel=NULL, text.panel=panel.txt,
cex.labels = 0.6, cor.method='pearson')
# Idea: AMOUNT/DURATION variable? (~ "monthly burden")
gcredit$AMOUNT_TO_DURATION <- gcredit$AMOUNT/gcredit$DURATION
gcredit$DURATION_TO_AGE <- gcredit$DURATION/gcredit$AGE
gcredit$AMOUNT_TO_AGE <- gcredit$AMOUNT/gcredit$AGE
ggplot(gcredit, aes(factor(RES), AMOUNT)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "AMOUNT boxplot", x="RES", y="AMOUNT")
ggplot(gcredit, aes(factor(RES), DURATION)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "DURATION boxplot", x="RES", y="DURATION")
ggplot(gcredit, aes(factor(RES), AGE)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "AGE boxplot", x="AGE", y="DURATION")
ggplot(gcredit, aes(factor(RES), AMOUNT_TO_DURATION)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "AMOUNT_TO_DURATION boxplot", x="RES", y="AMOUNT_TO_DURATION")
ggplot(gcredit, aes(factor(RES), DURATION_TO_AGE)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "DURATION_TO_AGE boxplot", x="RES", y="DURATION_TO_AGE")
ggplot(gcredit, aes(factor(RES), AMOUNT_TO_AGE)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "AMOUNT_TO_AGE boxplot", x="RES", y="AMOUNT_TO_AGE")
#' -----------------------------------------------------------------------------
#' Binning countinuous variables:
#'   - compare Information Value from equal frequency discretization and
#'     optimal discretization
#'
#'   - why to categorize variables?
#'     * http://blog.revolutionanalytics.com/2015/03/r-package-smbinning-optimal-binning-for-scoring-modeling.html
#'     * http://www.rcreditscoring.com/binning-continuous-variables-in-r-the-basics/
# Define subset of numeric variables
=======
<<fig.width=12, fig.height=4, out.width='.99\\linewidth'>>=
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
require(grid)
# Make a list from the ... arguments and plotlist
plots <- c(list(...), plotlist)
numPlots = length(plots)
# If layout is NULL, then use 'cols' to determine layout
if (is.null(layout)) {
# Make the panel
# ncol: Number of columns of plots
# nrow: Number of rows needed, calculated from # of cols
layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
ncol = cols, nrow = ceiling(numPlots/cols))
}
if (numPlots==1) {
print(plots[[1]])
} else {
# Set up the page
grid.newpage()
pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
# Make each plot, in the correct location
for (i in 1:numPlots) {
# Get the i,j matrix positions of the regions that contain this subplot
matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
layout.pos.col = matchidx$col))
}
}
}
p1 <- ggplot(gcredit, aes(factor(RES), AMOUNT)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "", x="RES", y="AMOUNT")
p2 <- ggplot(gcredit, aes(factor(RES), DURATION)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "", x="RES", y="DURATION")
p3 <- ggplot(gcredit, aes(factor(RES), AGE)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "", x="RES", y="AGE")
multiplot(p1, p2, p3, cols=3)
@
# Create derived variables
gcredit$AMOUNT_TO_DURATION <- gcredit$AMOUNT/gcredit$DURATION
gcredit$DURATION_TO_AGE <- gcredit$DURATION/gcredit$AGE
gcredit$AMOUNT_TO_AGE <- gcredit$AMOUNT/gcredit$AGE
p1 <- ggplot(gcredit, aes(factor(RES), AMOUNT_TO_DURATION)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "", x="RES", y="AMOUNT_TO_DURATION")
p2 <- ggplot(gcredit, aes(factor(RES), DURATION_TO_AGE)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "", x="RES", y="DURATION_TO_AGE")
p3 <- ggplot(gcredit, aes(factor(RES), AMOUNT_TO_AGE)) + geom_boxplot(aes(fill = factor(RES))) +
scale_fill_discrete(name = "RES") + labs(title = "", x="RES", y="AMOUNT_TO_AGE")
multiplot(p1, p2, p3, cols=3)
>>>>>>> 1b9fd1c652051485f7c6d8d386cd40424d20c20d
var.to.cat.names <- c("AGE", "AMOUNT_TO_AGE", "AMOUNT_TO_DURATION","AMOUNT", "DURATION", "DURATION_TO_AGE")
gcredit.quan <- gcredit[,c(var.to.cat.names, "RES")]
# Categorize variables in 3 ways. Keep categorized variable in a data frame
for(var.name in var.to.cat.names){
print(var.name)
x <- gcredit.quan[, var.name]
y <- gcredit.quan[, "RES"]
# Categorize variable with optimal binning with conditional tree
# (smbinning package)
mincriterion.tmp = 0.95
binning.res <- smbinning.custom(df=gcredit.quan, y="RES", x=var.name,
mincriterion = mincriterion.tmp)
# Check if we got requested num of bins
while(binning.res == "No Bins"){#} || (length(binning.res$bands)-1) < min.smbin.bins.num){
mincriterion.tmp = mincriterion.tmp - 0.05
print(mincriterion.tmp)
binning.res <- smbinning.custom(df=gcredit.quan, y="RES", x=var.name,
mincriterion = mincriterion.tmp)
}
binned.var.name <- paste0(var.name, "_bin")
gcredit.quan <- smbinning.gen(gcredit.quan, binning.res, binned.var.name)
# Correct new variable to be a factor
binned.var.levels <- sort(unique(gcredit.quan[, binned.var.name]))
gcredit.quan[, binned.var.name] <- factor(gcredit.quan[, binned.var.name],
levels = binned.var.levels,
labels = binned.var.levels)
n.bins <- length(binning.res$bands)-1
# Categorize variable with simple tree model (rpart package)
rparted.var <- cutRpart(x, y)
gcredit.quan[, paste0(var.name, "_rpart")] <- rparted.var
n.rparts <- length(levels(rparted.var))
# Categorize variable with equal frequency discretization
# (for defined num of bins we got in 1. optimal binning and 2. rpart binning)
gcredit.quan[, paste0(var.name, "_equal_nbins")] <- cutEqual(x, n.bins)
gcredit.quan[, paste0(var.name, "_equal_nrparts")] <- cutEqual(x, n.rparts)
}
# # Compare information value of those
# # download woe-master.zip from https://github.com/tomasgreif/woe and unzip it;
# # the install from source:
# #install.packages("/home/martakarass/Downloads/woe-master", repos = NULL, type="source")
# library(woe)
iv.df <- iv.mult(gcredit.quan, "RES", TRUE)
iv.df
# Build data frame to compare information values
iv.comp.df <- data.frame(var.name = numeric(0),
cat.sgn = numeric(0),
iv = numeric(0))
for(i in 1:(nrow(iv.df))){
n.tmp <- nrow(iv.comp.df)
var.name.tmp <- iv.df[i, "Variable"]
if(grepl("_bin", var.name.tmp)){
iv.comp.df[n.tmp+1, ] <- c(str_replace(var.name.tmp, "_bin", ""), "smbinning", iv.df[i, "InformationValue"])
} else if (grepl("_equal_nbins", var.name.tmp)){
iv.comp.df[n.tmp+1, ] <- c(str_replace(var.name.tmp, "_equal_nbins", ""), "equal_nbins", iv.df[i, "InformationValue"])
} else if (grepl("_equal_nrparts", var.name.tmp)){
iv.comp.df[n.tmp+1, ] <- c(str_replace(var.name.tmp, "_equal_nrparts", ""), "equal_nrparts", iv.df[i, "InformationValue"])
} else if (grepl("_rpart", var.name.tmp)){
iv.comp.df[n.tmp+1, ] <- c(str_replace(var.name.tmp, "_rpart", ""), "rpart", iv.df[i, "InformationValue"])
}
}
iv.comp.df$iv <- round(as.numeric(iv.comp.df$iv), 3)
iv.comp.df$var.name <- factor(iv.comp.df$var.name , levels = var.to.cat.names)
<<<<<<< HEAD
dput(iv.comp.df, "./data/iv-comparision-df")
rm(iv.comp.df)
# Plot
iv.comp.df <- dget("./data/iv-comparision-df")
ggplot(iv.comp.df, aes(var.name, iv, group = cat.sgn, colour = cat.sgn)) +
geom_line() + theme(axis.text.x = element_text(angle = 10, hjust = 1)) +
scale_fill_discrete(name = "approach sgn") +
labs(title = "AMOUNT_TO_AGE boxplot", x="RES", y="AMOUNT_TO_AGE")
gcredit.cat <- data.frame(RES = gcredit.quan$RES,
DURATION = gcredit.quan$DURATION_bin,
AGE = gcredit.quan$AGE_bin,
AMOUNT = gcredit.quan$AMOUNT_bin,
AMOUNT_TO_DURATION = gcredit.quan$AMOUNT_TO_DURATION_bin,
DURATION_TO_AGE = gcredit.quan$DURATION_TO_AGE_bin,
AMOUNT_TO_AGE = gcredit.quan$AMOUNT_TO_AGE_bin)
#' -----------------------------------------
#' Joining levels of categorical variables if reasonable.
#'
#' The point is that maybe some levels of categorical variables
#' are very similar in terms of rate of bad clients AND they are
#' reasonalby similar in terms of their meaning (e.g. for PURPOSE variable
#' its levels: "car (new)" and "car (old)"). Maybe
#' it is worth to "join" levels of these variables
#' in order to reduce "mess" in data.
y <- gcredit$RES
# ---------------
# gcredit$PURPOSE ******************
x.tmp <- gcredit$PURPOSE
res.df.tmp <- infval.comb.levels.effect(y, x.tmp, mosaic.plot = FALSE)
head(res.df.tmp)
iv.plot.woe(iv.mult(gcredit,"RES",vars=c("PURPOSE"),summary=FALSE))
# Połączenie leveli i zapamiętanie zmiennej
x.tmp <- combine.factor.lvls(x.tmp, c(res.df.tmp[2,1], res.df.tmp[2,2]))
gcredit.cat$PURPOSE <- x.tmp
# ---------------
# gcredit$RATE_TO_DISP_INCOME
x.tmp <- gcredit$RATE_TO_DISP_INCOME
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# Hopeless variable :P
gcredit.cat$RATE_TO_DISP_INCOME <- x.tmp
# ---------------
# gcredit$RESIDENCE
x.tmp <- gcredit$RESIDENCE
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# Hopeless variable :P
gcredit.cat$RESIDENCE <- x.tmp
# ---------------
# gcredit$NUM_OF_THIS_BANK_CREDITS
x.tmp <- gcredit$NUM_OF_THIS_BANK_CREDITS
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# Hopeless variable :P
gcredit.cat$NUM_OF_THIS_BANK_CREDITS <- x.tmp
# ---------------
# gcredit$NUM_OF_MAINTAINED_PEOPLE
x.tmp <- gcredit$NUM_OF_MAINTAINED_PEOPLE
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# Hopeless variable :P
gcredit.cat$NUM_OF_MAINTAINED_PEOPLE <- x.tmp
# ---------------
# gcredit$CHK_ACCT
x.tmp <- gcredit$CHK_ACCT
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# good variable; we do not change nothing!! :)
gcredit.cat$CHK_ACCT <- x.tmp
# ---------------
# gcredit$HISTORY
x.tmp <- gcredit$HISTORY
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# no logical reason to join anything :P
gcredit.cat$HISTORY <- x.tmp
# ---------------
# gcredit$SAVINGS_ACCT
x.tmp <- gcredit$SAVINGS_ACCT
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# we do not join "<100 DM" AND "100-500 DM" because
# "<100 DM" is relatively numerous in comparision to others
gcredit.cat$SAVINGS_ACCT <- x.tmp
# ---------------
# gcredit$EMLOYMENT
x.tmp <- gcredit$EMLOYMENT
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# we do not join e.g. "4-7 years" and ">= 7 years"
# because we would disorder frequencies in the levels
gcredit.cat$EMLOYMENT <- x.tmp
# ---------------
# gcredit$STATUS_AND_SEX
x.tmp <- gcredit$STATUS_AND_SEX
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
# SEX
gcredit$SEX <- sapply(gcredit$STATUS_AND_SEX, function(val){
ifelse(grepl("female",val), "female", "male")
})
gcredit$SEX <- as.factor(gcredit$SEX)
x.tmp <- gcredit$SEX
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
gcredit$STATUS <- as.factor(gcredit$STATUS)
# nope i do not touch this strange not nice variable :P
gcredit.cat$STATUS_AND_SEX <- gcredit$STATUS_AND_SEX
# ---------------
# gcredit$OTHER_DEBTORS
x.tmp <- gcredit$OTHER_DEBTORS
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
gcredit.cat$OTHER_DEBTORS <- x.tmp
# ---------------
# gcredit$PROPERTY
x.tmp <- gcredit$PROPERTY
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
gcredit.cat$PROPERTY <- x.tmp
# ---------------
# gcredit$OTHER_INSTALLMENT_PLANS
x.tmp <- gcredit$OTHER_INSTALLMENT_PLANS
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
gcredit.cat$OTHER_INSTALLMENT_PLANS <- x.tmp
# ---------------
# gcredit$HOUSING
x.tmp <- gcredit$HOUSING
res.df.tmp <- infval.comb.levels.effect(y, x.tmp)
head(res.df.tmp)
iv.plot.woe(iv.mult(gcredit,"RES",vars=c("HOUSING"),summary=FALSE))
# Połączenie leveli i zapamiętanie zmiennej
x.tmp <- combine.factor.lvls(x.tmp, c(res.df.tmp[2,1], res.df.tmp[2,2]))
gcredit.cat$HOUSING <- x.tmp
# ---------------
# gcredit$JOB
x.tmp <- gcredit$JOB
res.df.tmp <- infval.comb.levels.effect(y, x.tmp)
head(res.df.tmp)
iv.plot.woe(iv.mult(gcredit,"RES",vars=c("JOB"),summary=FALSE))
x.tmp <- combine.factor.lvls(x.tmp, c(res.df.tmp[4,1], res.df.tmp[4,2]))
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
gcredit.cat$JOB <- x.tmp
# ---------------
# gcredit$TELEPHONE
x.tmp <- gcredit$TELEPHONE
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
gcredit.cat$TELEPHONE <- x.tmp
# ---------------
# gcredit$IS_FOREIGN_WORKER
x.tmp <- gcredit$IS_FOREIGN_WORKER
(res.df.tmp <- infval.comb.levels.effect(y, x.tmp))
gcredit.cat$IS_FOREIGN_WORKER <- x.tmp
# ------------------------------------------------------------------------------
# Recode to WoE
# iv.num  - calculate WoE/IV for numeric variables
# iv.str - calculate WoE/IV for character/factor variables
# iv.mult - calculate WoE/IV, summary IV for one or more variables
# iv.plot.summary - plot IV summary
# iv.plot.woe - plot WoE patterns for one or more variables
# iv.replace.woe - recode original variables to WoE (adds new columns)
(iv.mult.res <- iv.mult(gcredit.cat, "RES", TRUE))
# Variable InformationValue Bins ZeroBins    Strength
# 1                  CHK_ACCT      0.666011503    4        0 Very strong
# 2                   HISTORY      0.293233547    5        0      Strong
# 3                  DURATION      0.229296148    3        0      Strong
# 4                    AMOUNT      0.225097717    4        0      Strong
# 5              SAVINGS_ACCT      0.196009557    5        0     Average
# 6                   PURPOSE      0.169155274    9        0     Average
# 7        AMOUNT_TO_DURATION      0.114469395    6        0     Average
# 8                  PROPERTY      0.112638262    4        0     Average
# 9                 EMLOYMENT      0.086433631    5        0        Weak
# 10                  HOUSING      0.082950783    2        0        Weak
# 11                      AGE      0.073166424    2        0        Weak
# 12  OTHER_INSTALLMENT_PLANS      0.057614542    3        0        Weak
# 13           STATUS_AND_SEX      0.044670678    4        0        Weak
# 14        IS_FOREIGN_WORKER      0.043877412    2        0        Weak
# 15            OTHER_DEBTORS      0.032019322    3        0        Weak
# 16      RATE_TO_DISP_INCOME      0.023858552    2        0        Weak
# 17 NUM_OF_THIS_BANK_CREDITS      0.010083557    2        0   Wery weak
# 18                      JOB      0.008095050    3        0   Wery weak
# 19                TELEPHONE      0.006377605    2        0   Wery weak
# 20 NUM_OF_MAINTAINED_PEOPLE      0.000000000    1        0   Wery weak
# 21                RESIDENCE      0.000000000    1        0   Wery weak
#' At this point we REMOVE:
#' - NUM_OF_MAINTAINED_PEOPLE
#' - RESIDENCE
#' variables
#'
#'
dput(gcredit.cat, file = "./data/german_data_cat-before-removal.txt" )
gcredit.cat.before.removal <- dget(gcredit.cat)
(iv.mult.res <- iv.mult(gcredit.cat.before.removal,"RES", TRUE))
dput(gcredit.cat, file = "./data/german_data_cat-before-removal.txt" )
gcredit.cat.before.removal <- dget("./data/german_data_cat-before-removal.txt")
(iv.mult.res <- iv.mult(gcredit.cat.before.removal,"RES", TRUE))
str(gcredit.cat)
gcredit.cat <-
read.table("./data/german_data_cat.txt", sep=",", header =TRUE,
colClasses=c(rep("numeric", 1), rep("character", 23)))
gcredit.cat.before.removal <- dget("./data/german_data_cat-before-removal.txt")
iv.mult.res <- iv.mult(gcredit.cat.before.removal,"RES", TRUE)
print(res)
col.to.remove.idx <- which(names(gcredit.cat) %in% c("NUM_OF_MAINTAINED_PEOPLE", "RESIDENCE"))
gcredit.cat <- gcredit.cat[, -col.to.remove.idx]
(iv.mult.res <- iv.mult(gcredit.cat,"RES", TRUE))
# ------------------------------------------------------------------------------
# Save categorized data to a file
# Reorder columns in data frame to have firsty numeric, then factor variables
num.cols <- which(sapply(gcredit.cat, class) == "numeric")
gcredit.cat <- gcredit.cat[c(num.cols, setdiff(1:ncol(gcredit.cat), num.cols))]
# Save tmp version of the data
write.table(x = gcredit.cat, file = "./data/german_data_cat.txt",
sep=",",  col.names=TRUE, row.names = FALSE)
str(gcredit.cat)
gcredit.cat <-
read.table("./data/german_data_cat.txt", sep=",", header =TRUE,
colClasses=c(rep("numeric", 1), rep("character", 21)))
gcredit.woe <-
read.table("./data/german_data_woe.txt", sep=",", header =TRUE,
colClasses=c(rep("numeric", 22)))
=======
_knitr::knit2pdf
?knitr::knit2pdf
warnings()
wd <- "C:/Users/jidziak/Desktop/project-scoring-data"
}
setwd(wd)
library(stringr)
source("./R/conf.R")
print("janek")
gcredit <-
read.table(paste0(wd,"/data/german_data_processed1.txt"), sep=",", header =TRUE, colClasses=c(rep("numeric", 8), rep("character", 13)))
>>>>>>> 1b9fd1c652051485f7c6d8d386cd40424d20c20d
