library(hydroGOF)
library(ggplot2)
library(dplyr)
library(reshape2)
library(rbenchmark)
library(locfit)
library(wavethresh)
library(changepoint)
library(MASS)
library(gplots)
#install.packages("devtools")
#library(devtools)
# install_github("baptiste/gridplot")
library(gridplot)
library(Rmisc)
# ------------------------------------------------------------------------------
# Source project util scripts
source("./R/util/UTIL-simulations.R")
# -----------------------------------------------------------------------------
# Other settings
# options(stringsAsFactors = TRUE)
# Pobronić się przed tym, żeby 3*sd yło mniejsze, niż odległość między punktami
# Parametry symulacji
SNR.vec <- c(6, 3, 1.6)
scene.nums <- list(c(32, 32), c(21, 22, 21), c(21, 22, 21))
scene.means <- list(c(0,1), c(0,1, 2), c(0,1,-1))
scenes.list <-
list(list(scene.nums[[1]], scene.means[[1]], SNR.vec[1]),
list(scene.nums[[2]], scene.means[[2]], SNR.vec[1]),
list(scene.nums[[3]], scene.means[[3]], SNR.vec[1]),
list(scene.nums[[1]], scene.means[[1]], SNR = SNR.vec[2]),
list(scene.nums[[2]], scene.means[[2]], SNR = SNR.vec[2]),
list(scene.nums[[3]], scene.means[[3]], SNR = SNR.vec[2]),
list(scene.nums[[1]], scene.means[[1]], SNR = SNR.vec[3]),
list(scene.nums[[2]], scene.means[[2]], SNR = SNR.vec[3]),
list(scene.nums[[3]], scene.means[[3]], SNR = SNR.vec[3]))
#' Funkcja zwracająza wartość: min(frac(a pokrywa b), frac(b pokrywa a))
#' dla dwóch odcinków a, b zadanych przez dwuelementowy wektor ozn. ich początek
#' i koniec
#'
xy.cover.frac <- function(x.range, y.range){
x.range.s <- sort(x.range)
y.range.s <- sort(y.range)
x1 <- x.range.s[1]
x2 <- x.range.s[2]
y1 <- y.range.s[1]
y2 <- y.range.s[2]
xh <- x2-x1
yh <- y2-y1
if(x2 <= y1 || y2 <= x1){
# Nie nachodzą w ogóle
return(0)
} else if(x1 <= y1 && y2 <= x2){
# x pokrywa całkowicie y
return(yh/xh)
} else if(y1 <= x1 && x2 <= y2){
# y pokrywa całkowicie x
return(xh/yh)
} else if(y1 <= x1){
# y "wystaje" na lewo od x
x.cov <- (y2-x1)/xh
y.cov <- (y2-x1)/yh
return(min(x.cov, y.cov))
} else if(x1 <= y1){
# y "wystaje" na prawo od x
x.cov <- (x2-y1)/xh
y.cov <- (x2-y1)/yh
return(min(x.cov, y.cov))
} else {
stop("Blad programisty! =)")
}
}
# # Example
# xy.cover.frac(c(1,2), c(1,2))
# xy.cover.frac(c(1,2), c(1,3))
# xy.cover.frac(c(1,2), c(1,4))
# xy.cover.frac(c(1,2), c(2,3))
# xy.cover.frac(c(1,4), c(2,3))
# xy.cover.frac(c(5,-1), c(-5,-2))
# xy.cover.frac(c(5,1), c(5,2))
# Zbudowanie listy opisującej rzeczywisty frame x dla danego sd.fixed
get.x.descriptor <- function(x, sd.fixed){
# Esktrakcja wartości z x
n <- length(x)
x.diff <- c(diff(x),0)
x.cp <- cp.indices(x)
x.cp.num <- length(x.cp)
x.cp.starts <- x
x.cp.ends <- x + x.diff
#' Wyznaczenie parametru skalującego, przez który mnożymy otrzymane funkcje
#' gęstości rozkładu normalnego okalającego cp rzeczywisty tak,
#' aby wartość funkcji gęstości w centrum była równa 1
#' (wyznaczenie dla zadanego odchylenia standardowego)
diff.kernels.height <- function(scale.par=1){
#sum(sapply(x.cp, function(index) dnorm(0, sd=sd.fixed)*scale.par*abs(x.diff[index])))
sum(sapply(x.cp, function(index) dnorm(0, sd=sd.fixed)*scale.par))
}
kernels.height.par <- x.cp.num/diff.kernels.height()
#' Funkcja zwracająca wartości sumy funcji okalającej (sumy kernelów) w danym punkcie,
#' dla tego konkretnego scenariuza symulacyjnego
diff.kernels.f <- function(x0, scale.par=kernels.height.par, do.abs=TRUE){
#sum(sapply(x.cp, function(index)  dnorm(x0, mean = index, sd=sd.fixed)*scale.par*abs(x.diff[index])))
sum(sapply(x.cp, function(index){
sgn.par <- ifelse(do.abs, 1, sign(x.diff[index]))
dnorm(x0, mean = index, sd=sd.fixed)*scale.par*sgn.par
}))
}
list(n=n,
x.diff=x.diff,
x.cp=x.cp,
x.cp.num=x.cp.num,
x.cp.starts=x.cp.starts,
x.cp.ends=x.cp.ends,
diff.kernels.f=diff.kernels.f)
}
x.descr <- get.x.descriptor(x, sd.fixed)
set.seed(1)
x <- scene.frame(scene.nums[[3]], scene.means[[3]])
scene.tmp <- simulate.scene2(scene.nums[[3]], scene.means[[3]])
y <- estimated.means.cumseg(scene.tmp)
sd.fixed <- 0.7
x.descr <- get.x.descriptor(x, sd.fixed)
x.descr
x.grid <- seq(1, n, length.out = n*100)
plot(x.grid, sapply(x.grid, function(x0) x.descr$diff.kernels.f(x0, do.abs = FALSE)), type="l")
x.grid <- seq(1, x.descr$n, length.out = x.descr$n*100)
plot(x.grid, sapply(x.grid, function(x0) x.descr$diff.kernels.f(x0, do.abs = FALSE)), type="l")
# Zbudowanie listy opisującej rzeczywisty frame x dla danego sd.fixed
get.x.descriptor <- function(x, sd.fixed){
# Esktrakcja wartości z x
n <- length(x)
x.diff <- c(diff(x),0)
x.cp <- cp.indices(x)
x.cp.num <- length(x.cp)
x.cp.starts <- x
x.cp.ends <- x + x.diff
#' Wyznaczenie parametru skalującego, przez który mnożymy otrzymane funkcje
#' gęstości rozkładu normalnego okalającego cp rzeczywisty tak,
#' aby wartość funkcji gęstości w centrum była równa 1
#' (wyznaczenie dla zadanego odchylenia standardowego)
diff.kernels.height <- function(scale.par=1){
#sum(sapply(x.cp, function(index) dnorm(0, sd=sd.fixed)*scale.par*abs(x.diff[index])))
sum(sapply(x.cp, function(index) dnorm(0, sd=sd.fixed)*scale.par))
}
kernels.height.par <- x.cp.num/diff.kernels.height()
#' Funkcja zwracająca wartości sumy funcji okalającej (sumy kernelów) w danym punkcie,
#' dla tego konkretnego scenariuza symulacyjnego
diff.kernels.f <- function(x0, scale.par=kernels.height.par, do.abs=TRUE){
#sum(sapply(x.cp, function(index)  dnorm(x0, mean = index, sd=sd.fixed)*scale.par*abs(x.diff[index])))
sum(sapply(x.cp, function(index){
sgn.par <- ifelse(do.abs, 1, sign(x.diff[index]))
dnorm(x0, mean = index, sd=sd.fixed)*scale.par*sgn.par
}))
}
list(x=x,
n=n,
x.diff=x.diff,
x.cp=x.cp,
x.cp.num=x.cp.num,
x.cp.starts=x.cp.starts,
x.cp.ends=x.cp.ends,
diff.kernels.f=diff.kernels.f)
}
# Ekstrakcja wartości ESTYMOWANYCH
y.diff <- c(diff(y),0)
y.cp <- cp.indices(y)
y.cp.starts <- y
y.cp.ends <- y + y.diff
y.cp.i <- 1
y.cp
y.cp.tmp <- y.cp[y.cp.i]
y.cp.tmp
abs.vec <- abs(x.descr$x.cp-y.cp.tmp)
abs.vec
x.descr$x.cp[which(abs.vec == min(abs.vec))[1]]
matched.x.cp.i <- x.descr$x.cp[which(abs.vec == min(abs.vec))[1]]
matched.x.cp.i
x.range <- c(x.descr$x.cp.starts[matched.x.cp.i], x.descr$x.cp.ends[matched.x.cp.i])
x.range
y.range <- c(y.cp.starts[y.cp.tmp], y.cp.ends[y.cp.tmp])
y.range
x.range <- c(x.descr$x.cp.starts[matched.x.cp.i], x.descr$x.cp.ends[matched.x.cp.i])
y.range <- c(y.cp.starts[y.cp.tmp], y.cp.ends[y.cp.tmp])
xy.cover.frac.val <- xy.cover.frac(x.range, y.range)
xy.cover.frac.val
matched.x.cp.i
y.cp.tmp
x.descr$diff.kernels.f(y.cp.tmp)
diff.kernels.f.val <- x.descr$diff.kernels.f(y.cp.tmp)
FD <- xy.cover.frac.val*diff.kernels.f.val
xy.cover.frac.val*diff.kernels.f.val
FD <- sqrt(((1-xy.cover.frac.val)^2 + (1-diff.kernels.f.val)^2)/2)
FD
get.y.descriptor <- function(y){
# Esktrakcja wartości z x
y.diff <- c(diff(y),0)
y.cp <- cp.indices(y)
y.cp.starts <- y
y.cp.ends <- y + y.diff
list(y=y,
y.diff=y.diff,
y.cp=y.cp,
y.cp.starts=y.cp.starts,
y.cp.ends=y.cp.ends)
}
y.descr <- get.y.descriptor(y)
# Wskazanie najbliższego rzeczywistego cp
abs.vec <- abs(x.descr$x.cp-y.descr$y.cp.tmp)
matched.x.cp <- x.descr$x.cp[which(abs.vec == min(abs.vec))[1]]
abs.vec
y.descr
abs.vec <- abs(x.descr$x.cp-y.cp.tmp)
matched.x.cp <- x.descr$x.cp[which(abs.vec == min(abs.vec))[1]]
x.range <- c(x.descr$x.cp.starts[matched.x.cp], x.descr$x.cp.ends[matched.x.cp])
y.range <- c(y.descr$y.cp.starts[y.cp.tmp], y.descr$y.cp.ends[y.cp.tmp])
xy.cover.frac.val <- xy.cover.frac(x.range, y.range)
diff.kernels.f.val <- x.descr$diff.kernels.f(y.cp.tmp)
FD <- sqrt(((1-xy.cover.frac.val)^2 + (1-diff.kernels.f.val)^2)/2)
FD
#' Wyznaczenie FD dla danego punktu cp estymowaneg
#'
#' @param y.cp.tmp - estymowany punkt cp
#' @param x.descr - lista opisująca x rzeczywisty
#' @param y.descr - lista opisująca x estymowany (ozn. "y")
#'
compute.y.cp.FD <- function(y.cp.tmp, x.descr, y.descr){
# Wskazanie najbliższego rzeczywistego cp
abs.vec <- abs(x.descr$x.cp-y.cp.tmp)
matched.x.cp <- x.descr$x.cp[which(abs.vec == min(abs.vec))[1]]
# Wyznaczenie wartości pokrycia
x.range <- c(x.descr$x.cp.starts[matched.x.cp], x.descr$x.cp.ends[matched.x.cp])
y.range <- c(y.descr$y.cp.starts[y.cp.tmp], y.descr$y.cp.ends[y.cp.tmp])
xy.cover.frac.val <- xy.cover.frac(x.range, y.range)
# Wyznaczenie wartości gęstości
diff.kernels.f.val <- x.descr$diff.kernels.f(y.cp.tmp)
# Wyznaczenie FDR
FD <- sqrt(((1-xy.cover.frac.val)^2 + (1-diff.kernels.f.val)^2)/2)
}
#' @description
#' Project configuration file.
#'
#' Contains:
#'  - setting of working directory (depenfing on user's comupter name)
#'  - loading all libraries used in the project
#'  - sourcing of all util scipts used in project
# ------------------------------------------------------------------------------
# Set working directory
computer.name <- Sys.info()["nodename"]
if (computer.name == "marta-komputer")
wd.tmp <- "/home/martakarass/Dropbox/MASTER"
setwd(wd.tmp)
# ------------------------------------------------------------------------------
# Load libraries
# install.packages("hydroGOF")
# install.packages("bcp")
# install.packages("strucchange") # (BP, Bai and Perron 2003)
# # install `DNAcopy` package
# source("http://bioconductor.org/biocLite.R")
# biocLite("DNAcopy")
# browseVignettes(package = "DNAcopy")
library(DNAcopy)
#library(SMAP)
library(bcp)
library(strucchange)
library(cumSeg)
library(hydroGOF)
library(ggplot2)
library(dplyr)
library(reshape2)
library(rbenchmark)
library(locfit)
library(wavethresh)
library(changepoint)
library(MASS)
library(gplots)
#install.packages("devtools")
#library(devtools)
# install_github("baptiste/gridplot")
library(gridplot)
library(Rmisc)
# ------------------------------------------------------------------------------
# Source project util scripts
source("./R/util/UTIL-simulations.R")
# -----------------------------------------------------------------------------
# Other settings
# options(stringsAsFactors = TRUE)
# Pobronić się przed tym, żeby 3*sd yło mniejsze, niż odległość między punktami
#' Funkcja zwracająza wartość: min(frac(a pokrywa b), frac(b pokrywa a))
#' dla dwóch odcinków a, b zadanych przez dwuelementowy wektor ozn. ich początek
#' i koniec
#'
xy.cover.frac <- function(x.range, y.range){
x.range.s <- sort(x.range)
y.range.s <- sort(y.range)
x1 <- x.range.s[1]
x2 <- x.range.s[2]
y1 <- y.range.s[1]
y2 <- y.range.s[2]
xh <- x2-x1
yh <- y2-y1
if(x2 <= y1 || y2 <= x1){
# Nie nachodzą w ogóle
return(0)
} else if(x1 <= y1 && y2 <= x2){
# x pokrywa całkowicie y
return(yh/xh)
} else if(y1 <= x1 && x2 <= y2){
# y pokrywa całkowicie x
return(xh/yh)
} else if(y1 <= x1){
# y "wystaje" na lewo od x
x.cov <- (y2-x1)/xh
y.cov <- (y2-x1)/yh
return(min(x.cov, y.cov))
} else if(x1 <= y1){
# y "wystaje" na prawo od x
x.cov <- (x2-y1)/xh
y.cov <- (x2-y1)/yh
return(min(x.cov, y.cov))
} else {
stop("Blad programisty! =)")
}
}
# # Example
# xy.cover.frac(c(1,2), c(1,2))
# xy.cover.frac(c(1,2), c(1,3))
# xy.cover.frac(c(1,2), c(1,4))
# xy.cover.frac(c(1,2), c(2,3))
# xy.cover.frac(c(1,4), c(2,3))
# xy.cover.frac(c(5,-1), c(-5,-2))
# xy.cover.frac(c(5,1), c(5,2))
# Zbudowanie listy opisującej rzeczywisty frame x dla danego sd.fixed
get.x.descriptor <- function(x, sd.fixed){
# Esktrakcja wartości z x
n <- length(x)
x.diff <- c(diff(x),0)
x.cp <- cp.indices(x)
x.cp.num <- length(x.cp)
x.cp.starts <- x
x.cp.ends <- x + x.diff
#' Wyznaczenie parametru skalującego, przez który mnożymy otrzymane funkcje
#' gęstości rozkładu normalnego okalającego cp rzeczywisty tak,
#' aby wartość funkcji gęstości w centrum była równa 1
#' (wyznaczenie dla zadanego odchylenia standardowego)
diff.kernels.height <- function(scale.par=1){
#sum(sapply(x.cp, function(index) dnorm(0, sd=sd.fixed)*scale.par*abs(x.diff[index])))
sum(sapply(x.cp, function(index) dnorm(0, sd=sd.fixed)*scale.par))
}
kernels.height.par <- x.cp.num/diff.kernels.height()
#' Funkcja zwracająca wartości sumy funcji okalającej (sumy kernelów) w danym punkcie,
#' dla tego konkretnego scenariuza symulacyjnego
diff.kernels.f <- function(x0, scale.par=kernels.height.par, do.abs=TRUE){
#sum(sapply(x.cp, function(index)  dnorm(x0, mean = index, sd=sd.fixed)*scale.par*abs(x.diff[index])))
sum(sapply(x.cp, function(index){
sgn.par <- ifelse(do.abs, 1, sign(x.diff[index]))
dnorm(x0, mean = index, sd=sd.fixed)*scale.par*sgn.par
}))
}
list(x=x,
n=n,
x.diff=x.diff,
x.cp=x.cp,
x.cp.num=x.cp.num,
x.cp.starts=x.cp.starts,
x.cp.ends=x.cp.ends,
diff.kernels.f=diff.kernels.f)
}
# Zbudowanie listy opisującej estymowane wartości y
get.y.descriptor <- function(y){
# Esktrakcja wartości z x
y.diff <- c(diff(y),0)
y.cp <- cp.indices(y)
y.cp.starts <- y
y.cp.ends <- y + y.diff
list(y=y,
y.diff=y.diff,
y.cp=y.cp,
y.cp.starts=y.cp.starts,
y.cp.ends=y.cp.ends)
}
#' Wyznaczenie FD dla danego punktu cp estymowaneg
#'
#' @param y.cp.tmp - estymowany punkt cp
#' @param x.descr - lista opisująca x rzeczywisty
#' @param y.descr - lista opisująca x estymowany (ozn. "y")
#'
compute.y.cp.FD <- function(y.cp.tmp, x.descr, y.descr){
# Wskazanie najbliższego rzeczywistego cp
abs.vec <- abs(x.descr$x.cp-y.cp.tmp)
matched.x.cp <- x.descr$x.cp[which(abs.vec == min(abs.vec))[1]]
# Wyznaczenie wartości pokrycia
x.range <- c(x.descr$x.cp.starts[matched.x.cp], x.descr$x.cp.ends[matched.x.cp])
y.range <- c(y.descr$y.cp.starts[y.cp.tmp], y.descr$y.cp.ends[y.cp.tmp])
xy.cover.frac.val <- xy.cover.frac(x.range, y.range)
# Wyznaczenie wartości gęstości
diff.kernels.f.val <- x.descr$diff.kernels.f(y.cp.tmp)
# Wyznaczenie FDR
FD <- sqrt(((1-xy.cover.frac.val)^2 + (1-diff.kernels.f.val)^2)/2)
}
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# ------------------------------------------------------------------------------
# Parametry symulacji
SNR.vec <- c(6, 3, 1.6)
scene.nums <- list(c(32, 32), c(21, 22, 21), c(21, 22, 21))
scene.means <- list(c(0,1), c(0,1, 2), c(0,1,-1))
scenes.list <-
list(list(scene.nums[[1]], scene.means[[1]], SNR.vec[1]),
list(scene.nums[[2]], scene.means[[2]], SNR.vec[1]),
list(scene.nums[[3]], scene.means[[3]], SNR.vec[1]),
list(scene.nums[[1]], scene.means[[1]], SNR = SNR.vec[2]),
list(scene.nums[[2]], scene.means[[2]], SNR = SNR.vec[2]),
list(scene.nums[[3]], scene.means[[3]], SNR = SNR.vec[2]),
list(scene.nums[[1]], scene.means[[1]], SNR = SNR.vec[3]),
list(scene.nums[[2]], scene.means[[2]], SNR = SNR.vec[3]),
list(scene.nums[[3]], scene.means[[3]], SNR = SNR.vec[3]))
set.seed(1)
x <- scene.frame(scene.nums[[3]], scene.means[[3]])
scene.tmp <- simulate.scene2(scene.nums[[3]], scene.means[[3]])
y <- estimated.means.cumseg(scene.tmp)
sd.fixed <- 0.7
x.descr <- get.x.descriptor(x, sd.fixed)
y.descr <- get.y.descriptor(y)
res <- sapply(y.descr$y.cp, function(y.cp.tmp) compute.y.cp.FD(y.cp.tmp, x.descr, y.descr))
res
y.descr$y.cp
sapply(c(10, y.descr$y.cp), function(y.cp.tmp) compute.y.cp.FD(y.cp.tmp, x.descr, y.descr))
FD.convolution <- function(x, y){
x.descr <- get.x.descriptor(x, sd.fixed)
y.descr <- get.y.descriptor(y)
FDR <- mean(sapply(y.descr$y.cp, function(y.cp.tmp) compute.y.cp.FD(y.cp.tmp, x.descr, y.descr)))
return(FDR)
}
FD.convolution <- function(x, y){
x.descr <- get.x.descriptor(x, sd.fixed)
y.descr <- get.y.descriptor(y)
FDR <- mean(sapply(y.descr$y.cp, function(y.cp.tmp) compute.y.cp.FD(y.cp.tmp, x.descr, y.descr)))
return(FDR)
}
FD.convolution <- function(x, y, sd.fixed){
x.descr <- get.x.descriptor(x, sd.fixed)
y.descr <- get.y.descriptor(y)
FDR <- mean(sapply(y.descr$y.cp, function(y.cp.tmp) compute.y.cp.FD(y.cp.tmp, x.descr, y.descr)))
return(FDR)
}
FD.convolution(x, y, 0.7)
FD.convolution(x, y, 0.5)
FD.convolution(x, y, 0.1)
y
diff(y)
cp.indices(y)
cp.indices(x)
FD.convolution(x, y, 0.01)
?fdr
install.packages("knitr")
install.packages("corrgram")
#' @description
#' Project configuration file.
#'
#' Contains:
#'  - setting of working directory (depenfing on user's comupter name)
#'  - loading all libraries used in the project
#'  - sourcing of all util scipts used in project
# ------------------------------------------------------------------------------
# Set working directory
computer.name <- Sys.info()["nodename"]
if (computer.name == "marta-komputer")
wd.tmp <- "/home/martakarass/my-store/studies/PW/project-scoring-data"
if (computer.name == "MATHPASSION")
wd.tmp <- "C:/Users/Math/studia/studies/PW/project-scoring-data"
setwd(wd.tmp)
# ------------------------------------------------------------------------------
# Load libraries
library(corrgram)
library(ggplot2)
require(stringr)
#' To load `woe` package:
#' 1. download woe-master.zip from https://github.com/tomasgreif/woe
#' 2. unzip it
#' 3. install from source:
#' install.packages("/home/martakarass/Downloads/woe-master", repos = NULL, type="source")
library(woe)
library(caret)
library(pROC)
library(smbinning)
library(reshape)
library(dplyr)
library(MASS)
library(pander)
library(stringr)
# to install under Ubuntu, follow: http://stackoverflow.com/questions/13403268/error-while-loading-rjava
library(rJava)
library(RWekajars)
library(RWeka)
library(FSelector)
# ------------------------------------------------------------------------------
# Source project util scripts
source("./R/UTILS_data_preprocessing.R")
install.packages("stringr")
install.packages("stringr")
library(devtools)
install_github("tomasgreif/woe")
library(woe)
caret")
install.packages("caret")
install.packages("smbinning")
install.packages("pander")
install.packages("rJava")
Sys.getenv("JAVA_HOME")
if (Sys.getenv("JAVA_HOME")!="")
Sys.setenv(JAVA_HOME="")
install.packages("rJava")
